"use strict";(self.webpackChunk_1_inch_docs=self.webpackChunk_1_inch_docs||[]).push([[3847],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=a,h=u["".concat(c,".").concat(m)]||u[m]||p[m]||i;return n?r.createElement(h,o(o({ref:t},l),{},{components:n})):r.createElement(h,o({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},95188:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return l},default:function(){return u}});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),o=["components"],s={sidebar_position:3},c="Order creation examples",d={unversionedId:"limit-order-protocol/examples",id:"limit-order-protocol/examples",isDocsHomePage:!1,title:"Order creation examples",description:"Through @1inch/limit-order-protocol-utils",source:"@site/docs/limit-order-protocol/examples.mdx",sourceDirName:"limit-order-protocol",slug:"/limit-order-protocol/examples",permalink:"/docs/limit-order-protocol/examples",editUrl:"https://github.com/1inch/1inch-docs/edit/master/docs/limit-order-protocol/examples.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Limit vs. RFQ Orders",permalink:"/docs/limit-order-protocol/types"},next:{title:"About",permalink:"/docs/limit-order-protocol/utils/about"}},l=[{value:"Through <code>@1inch/limit-order-protocol-utils</code>",id:"through-1inchlimit-order-protocol-utils",children:[]},{value:"Python Example for 1inch Limit Order v3",id:"python-example-for-1inch-limit-order-v3",children:[]}],p={toc:l};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"order-creation-examples"},"Order creation examples"),(0,i.kt)("h2",{id:"through-1inchlimit-order-protocol-utils"},"Through ",(0,i.kt)("inlineCode",{parentName:"h2"},"@1inch/limit-order-protocol-utils")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"This is the recomended option!"))),(0,i.kt)("p",null,"There is ",(0,i.kt)("a",{parentName:"p",href:"./utils/about"},"JavaScript and Typescript compatible library")," that solves everything for you, we taking care on it to make everything up to date and make you migration over Limit Order Protocol Versions as smooth as possible."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"See ",(0,i.kt)("a",{parentName:"li",href:"./utils/guide/quick-start"},"docs on order creation")),(0,i.kt)("li",{parentName:"ul"},"See ",(0,i.kt)("a",{parentName:"li",href:"./utils/about"},"library docs"))),(0,i.kt)("br",null),(0,i.kt)("hr",null),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"python-example-for-1inch-limit-order-v3"},"Python Example for 1inch Limit Order v3"),(0,i.kt)("p",null,"To place a limit order in python requires more work since there's no library"),(0,i.kt)("p",null,"In this example the predicate only uses the timestamp to determine when the order should expire but there are many more functions that can be used for the predicate. See the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/1inch/limit-order-protocol-utils/"},"limit order protocol utils")," github for more information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from eth_account.messages import encode_structured_data\nfrom web3 import Web3\nimport requests\nimport time\nw3 = Web3(Web3.HTTPProvider("https://cloudflare-eth.com"))  # you can customize the RPC\nwallet_key = "..." # Your wallet private key without the leading 0x\nwallet_address = "..." # Your wallet address\nlimit_order_contract = "0x1111111254EEB25477B68fb85Ed929f73A960582" # the limit order contract (now the same as the 1inch v5 router)\nchain_id = 1 # the chain id of the network you are using ##didn\'t exist in the previoius version\nETHERSCAN_API_KEY = "yourapikeytoken" # Etherscan API key, this may not be required or should be changed if the ABIs are changed to literals or a different blockchain API is used like api.bscscan.com or api.polygonscan.com\n\n#create the limit order contract instance\nlimit_order_contract_abi_response = requests.get(f"https://api.etherscan.io/api?module=contract&action=getabi&address={limit_order_contract}&apikey={ETHERSCAN_API_KEY}")\nlimit_order_contract_abi = limit_order_contract_abi_response.json()["result"]\nlimit_order_contract_instance = w3.eth.contract(address=limit_order_contract, abi=limit_order_contract_abi)\n\n# wait 5 seconds to avoid rate limiting\ntime.sleep(5)\n\n# get the token addresses for the tokens you want to trade\nerc20_abi_response = requests.get(f"https://api.etherscan.io/api?module=contract&action=getabi&address=0x6b175474e89094c44da98b954eedeac495271d0f&apikey={ETHERSCAN_API_KEY}")\nerc20_abi = erc20_abi_response.json()["result"]\n\n#here is were we define parameters for the limit order\nmakerAddress = Web3.toChecksumAddress(wallet_address) # the address of the wallet that will be the maker of the order\ntakerAddress = Web3.toChecksumAddress("0x0000000000000000000000000000000000000000") # the address of the taker, if it\'s address(0) then it\'s a public order\nmakerAsset = Web3.toChecksumAddress("0x6b175474e89094c44da98b954eedeac495271d0f") # the address of the token you want to sell\ntakerAsset = Web3.toChecksumAddress("0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2") # the address of the token you want to buy\nmakerAmount = 1000 # the amount of the token you want to sell in wei\ntakerAmount = 1000000000000000000 # the amount of the token you want to buy in wei\n\nmakerAssetContract = w3.eth.contract(address=makerAsset, abi=erc20_abi)\ntakerAssetContract = w3.eth.contract(address=takerAsset, abi=erc20_abi)\n\n# other order parameters\nmakerAssetData = \'0x\'\ntakerAssetData = \'0x\'\ngetMakingAmount = \'0x\'\ngetTakingAmount = \'0x\'\nexpiration = 5444440000 # some time in the future\nnonce = 0 # the nonce of the order, used to be able to cancel all orders that have the same nonce by increasing the addresses\' nonce\nseriesNonceManagerContractAddress = w3.toChecksumAddress(\'0x303389f541ff2d620e42832f180a08e767b28e10\') # https://github.com/1inch/limit-order-protocol-utils/blob/fdbb559509eeb6e22e2697cccb22887d69617652/src/series-nonce-manager.const.ts\nseriesNonceManagerABI_response = requests.get(f"https://api.etherscan.io/api?module=contract&action=getabi&address={seriesNonceManagerContractAddress}&apikey={ETHERSCAN_API_KEY}")\nseriesNonceManagerABI = [{"inputs":[],"name":"AdvanceNonceFailed","type":"error"},{"anonymous":False,"inputs":[{"indexed":True,"internalType":"address","name":"maker","type":"address"},{"indexed":False,"internalType":"uint256","name":"series","type":"uint256"},{"indexed":False,"internalType":"uint256","name":"newNonce","type":"uint256"}],"name":"NonceIncreased","type":"event"},{"inputs":[{"internalType":"uint256","name":"series","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"advanceNonce","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint8","name":"series","type":"uint8"}],"name":"increaseNonce","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"address","name":"","type":"address"}],"name":"nonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"series","type":"uint256"},{"internalType":"address","name":"makerAddress","type":"address"},{"internalType":"uint256","name":"makerNonce","type":"uint256"}],"name":"nonceEquals","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"time","type":"uint256"}],"name":"timestampBelow","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"timeNonceSeriesAccount","type":"uint256"}],"name":"timestampBelowAndNonceEquals","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]\nseriesNonceManagerInstance = w3.eth.contract(address=seriesNonceManagerContractAddress, abi=seriesNonceManagerABI)\n')),(0,i.kt)("p",null,"One of the breaking changes with v3 was the addition of the offsets parameter and the packing of the interactions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# this data will be all packed into the Interactions parameter\nseries = 0 # 0 is limit order 1 is p2p order\nnonceManagerCalldata = seriesNonceManagerInstance.encodeABI(fn_name="timestampBelow", args=[expiration])\npredicate = limit_order_contract_instance.encodeABI(fn_name="arbitraryStaticCall", args=[seriesNonceManagerContractAddress, nonceManagerCalldata] )\npermit = \'0x\' # this would be used to add an EIP 712 permit to the order\npreInteraction = \'0x\' # this would be used to add a pre-interaction to the order\npostInteraction = \'0x\' # this would be used to add a post-interaction to the order, for example unwrapping wETH to ETH\n\nall_interactions = [makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preInteraction, postInteraction]\n\n# this function will calculate the offsets for the interactions\ndef getOffsets(interactions):\n    lenghtMap = []\n    for interaction in interactions:\n        if interaction[0:2] == "0x":\n            lenghtMap.append(int(len(interaction)/2 - 1))\n        else:\n            lenghtMap.append(int(len(interaction)/2))\n    cumulativeSum = 0\n    bytesAccumularot = 0\n    index = 0\n    UINT32_BITS = 32\n    # print(lenghtMap)\n    for lenght in lenghtMap:\n        cumulativeSum += lenght\n        # bytesAccumularot + (BigInt(offset) << ((exports.UINT32_BITS * BigInt(index))));\n        # print(str(bytesAccumularot) + " + (" + str(cumulativeSum) + " << (" + str(UINT32_BITS) + " * " + str(index) + "))")\n        bytesAccumularot += cumulativeSum << (UINT32_BITS * index)\n        index += 1\n    offsets = bytesAccumularot #hex(bytesAccumularot)\n    return offsets\n\noffsets = getOffsets(all_interactions)\n\ndef trim0x(hexString):\n    if hexString[0:2] == \'0x\':\n        return hexString[2:]\n    return hexString\n\ninteractions = "0x"\nfor interaction in all_interactions:\n    interactions = interactions + trim0x(interaction)\n')),(0,i.kt)("p",null,"a limit order can't be signed properly if all the types are strings here we define what each field is and the type it should be"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'\norder_data = {\n    "salt": 0,\n    "makerAsset": makerAsset,\n    "takerAsset": takerAsset,\n    "maker": makerAddress,\n    "receiver": takerAddress,\n    "allowedSender": "0x0000000000000000000000000000000000000000",\n    "makerAmount": makerAmount,\n    "takerAmount": takerAmount,\n    "offsets": offsets,\n    "interactions": interactions\n}\n\norder_types = [\n    {"name": "salt", "type": "uint256"},\n    {"name": "makerAsset", "type": "address"},\n    {"name": "takerAsset", "type": "address"},\n    {"name": "maker", "type": "address"},\n    {"name": "receiver", "type": "address"},\n    {"name": "allowedSender", "type": "address"},\n    {"name": "makerAmount", "type": "uint256"},\n    {"name": "takerAmount", "type": "uint256"},\n    {"name": "offsets", "type": "uint256"},\n    {"name": "interactions", "type": "bytes"},\n]\n\n# this function will fix the order_data to be a typed object instead of only strings\ndef fix_data_types(data, types):\n    """\n    Order data values are all strings as this is what the API expects. This function fixes their types for\n    encoding purposes.\n    """\n    fixed_data = {}\n    for dictionary in types:\n        if "bytes" in dictionary["type"]:\n            fixed_data[dictionary["name"]] = (Web3.toBytes(hexstr=data[dictionary["name"]]))\n        elif "int" in dictionary["type"]:\n            fixed_data[dictionary["name"]] = int(data[dictionary["name"]])\n        else: # address\n            fixed_data[dictionary["name"]] = data[dictionary["name"]]\n    return fixed_data\n\n# this is a typed data that the private key will be signing, it conforms to the EIP 712 standard\neip712_data = {\n    "primaryType": "Order",\n    "types": {\n        "EIP712Domain": [\n            {"name": "name", "type": "string"},\n            {"name": "version", "type": "string"},\n            {"name": "chainId", "type": "uint256"},\n            {"name": "verifyingContract", "type": "address"},\n        ],\n        "Order": order_types\n    },\n    "domain": {\n        "name": "1inch Aggregation Router",\n        "version": "5",\n        "chainId": chain_id,\n        "verifyingContract": "0x1111111254eeb25477b68fb85ed929f73a960582",\n    },\n    "message": fix_data_types(order_data, order_types),\n}\n')),(0,i.kt)("p",null,"Finally the private key will be used to sign the encoded data and broadcast to the API"),(0,i.kt)("p",null,"If you are having problems signing please run the following commands:\n",(0,i.kt)("inlineCode",{parentName:"p"},"pip install web3 --upgrade; pip install eth-account==0.6.1")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'encoded_message = encode_structured_data(eip712_data)\nsigned_message = w3.eth.account.sign_message(encoded_message, wallet_key)\n# this is the limit order that will be broadcast to the limit order API\nlimit_order = {\n    "orderHash": signed_message.messageHash.hex(),\n    "signature": signed_message.signature.hex(),\n    "data": order_data,\n}\n\nlimit_order_url = "https://limit-orders.1inch.io/v3.0/"+ str(chain_id) +"/limit-order" # make sure to change the chain_id if you are not using ETH mainnet\nresponse = requests.post(url=limit_order_url,headers={"accept": "application/json, text/plain, */*", "content-type": "application/json"}, json=limit_order)\n# print the full response\nprint(response.text)\n')))}u.isMDXComponent=!0}}]);