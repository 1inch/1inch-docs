"use strict";(self.webpackChunk_1_inch_docs=self.webpackChunk_1_inch_docs||[]).push([[7698],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>k});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),s=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=s(a),u=n,k=p["".concat(c,".").concat(u)]||p[u]||m[u]||i;return a?r.createElement(k,l(l({ref:t},d),{},{components:a})):r.createElement(k,l({ref:t},d))}));function k(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[p]="string"==typeof e?e:n,l[1]=o;for(var s=2;s<i;s++)l[s]=a[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},38805:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var r=a(87462),n=(a(67294),a(3905));const i={sidebar_position:8},l="Predicate",o={unversionedId:"limit-order-protocol/utils/guide/predicate",id:"limit-order-protocol/utils/guide/predicate",title:"Predicate",description:"LimitOrderPredicateBuilder",source:"@site/docs/limit-order-protocol/utils/guide/predicate.md",sourceDirName:"limit-order-protocol/utils/guide",slug:"/limit-order-protocol/utils/guide/predicate",permalink:"/docs/limit-order-protocol/utils/guide/predicate",draft:!1,editUrl:"https://github.com/1inch/1inch-docs/edit/master/docs/limit-order-protocol/utils/guide/predicate.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Nonce",permalink:"/docs/limit-order-protocol/utils/guide/nonce"},next:{title:"SeriesNonceManager predicate",permalink:"/docs/limit-order-protocol/utils/guide/series-nonce-manager"}},c={},s=[{value:"<code>LimitOrderPredicateBuilder</code>",id:"limitorderpredicatebuilder",level:2},{value:"Conditional operators:",id:"conditional-operators",level:2},{value:"Comparative operators:",id:"comparative-operators",level:2},{value:"Built-in operators:",id:"built-in-operators",level:2},{value:"<code>timestampBelowAndNonceEquals</code>",id:"timestampbelowandnonceequals",level:3},{value:"<code>arbitraryStaticCall</code>",id:"arbitrarystaticcall",level:3},{value:"Deprecated built-in operators:",id:"deprecated-built-in-operators",level:2},{value:"Examples",id:"examples",level:2}],d={toc:s},p="wrapper";function m(e){let{components:t,...a}=e;return(0,n.kt)(p,(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"predicate"},"Predicate"),(0,n.kt)("h2",{id:"limitorderpredicatebuilder"},(0,n.kt)("inlineCode",{parentName:"h2"},"LimitOrderPredicateBuilder")),(0,n.kt)("p",null,"A limit order can contain one or more predicates that indicate the logic of its validity.",(0,n.kt)("br",{parentName:"p"}),"\n",(0,n.kt)("strong",{parentName:"p"},"There are two types of predicate operators:")),(0,n.kt)("h2",{id:"conditional-operators"},"Conditional operators:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"and")),(0,n.kt)("td",{parentName:"tr",align:null},"combine several predicates, return ",(0,n.kt)("inlineCode",{parentName:"td"},"true")," when all predicates are valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"or")),(0,n.kt)("td",{parentName:"tr",align:null},"combine several predicates, return ",(0,n.kt)("inlineCode",{parentName:"td"},"true")," when one of predicates is valid")))),(0,n.kt)("h2",{id:"comparative-operators"},"Comparative operators:"),(0,n.kt)("p",null,"All comparative operators have two arguments:  "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"[comparative](value: string, calldata: string)\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"How the operators works:"),"  "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"On an operator call, the contract execute the ",(0,n.kt)("inlineCode",{parentName:"li"},"calldata")," on the limit-order-protocol contract and compare ",(0,n.kt)("em",{parentName:"li"},(0,n.kt)("strong",{parentName:"em"},"a result"))," with the ",(0,n.kt)("inlineCode",{parentName:"li"},"value"),"."),(0,n.kt)("li",{parentName:"ul"},"In case if you need to call method on third party contract use ",(0,n.kt)("inlineCode",{parentName:"li"},"arbitraryStaticCall(targetAddress, calldata)"),".")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"eq")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("em",{parentName:"td"},(0,n.kt)("strong",{parentName:"em"},"a result"))," must be equal to the ",(0,n.kt)("inlineCode",{parentName:"td"},"value"))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"lt")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("em",{parentName:"td"},(0,n.kt)("strong",{parentName:"em"},"a result"))," must be less than the ",(0,n.kt)("inlineCode",{parentName:"td"},"value"))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"gt")),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("em",{parentName:"td"},(0,n.kt)("strong",{parentName:"em"},"a result"))," must be greater than the ",(0,n.kt)("inlineCode",{parentName:"td"},"value"))))),(0,n.kt)("h2",{id:"built-in-operators"},"Built-in operators:"),(0,n.kt)("h3",{id:"timestampbelowandnonceequals"},(0,n.kt)("inlineCode",{parentName:"h3"},"timestampBelowAndNonceEquals")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"timestampBelowAndNonceEquals(\n    timestamp: number | bigint,\n    makerNonce: number | bigint,\n    makerAddress: string\n)\n")),(0,n.kt)("p",null,"The predicate checks the same as ",(0,n.kt)("inlineCode",{parentName:"p"},"and(timestampBelow(), nonceEquals())"),"."),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"Gasless only!"))),(0,n.kt)("p",{parentName:"blockquote"},"For usual Limit Order and P2P use ",(0,n.kt)("a",{parentName:"p",href:"./series-nonce-manager"},(0,n.kt)("inlineCode",{parentName:"a"},"SeriesNonceManagerPredicateBuilder.timestampBelowAndNonceEquals(series, timestamp, nonce, maker)"))," together with ",(0,n.kt)("inlineCode",{parentName:"p"},"arbitraryStaticCall(target, calldata)"),". ",(0,n.kt)("br",null),"\nSee examples below.")),(0,n.kt)("h3",{id:"arbitrarystaticcall"},(0,n.kt)("inlineCode",{parentName:"h3"},"arbitraryStaticCall")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"arbitraryStaticCall(\n    targetAddress: string | Facade,\n    calldata: string\n)\n")),(0,n.kt)("p",null,"Allows to call methods on third party contracts."),(0,n.kt)("p",null,"Example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const predicate = arbitraryStaticCall(\n    seriesContractAddress, // target third-party contract address\n    seriesNonceManagerPredicateBuilder.nonceEquals(\u2026), // calldata to execute on it\n);\n\n// More convenient with facade\nconst predicate = arbitraryStaticCall(\n    seriesNonceManagerPredicateBuilder.facade, // facade stores contract address as well\n    seriesNonceManagerPredicateBuilder.nonceEquals(\u2026), // same calldata\n);\n")),(0,n.kt)("br",null),(0,n.kt)("h2",{id:"deprecated-built-in-operators"},"Deprecated built-in operators:"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"WARNING!"))),(0,n.kt)("p",{parentName:"blockquote"},(0,n.kt)("strong",{parentName:"p"},"To save gas")," consider using one of"),(0,n.kt)("ul",{parentName:"blockquote"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"./series-nonce-manager"},(0,n.kt)("inlineCode",{parentName:"a"},"SeriesNonceManagerPredicateBuilder.timestampBelowAndNonceEquals(\u2026)"))," \u2013 for everything but gasless"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"timestampBelowAndNonceEquals(\u2026)")," \u2013 for gasless only")),(0,n.kt)("p",{parentName:"blockquote"},"instead as it more optimal then separate ",(0,n.kt)("inlineCode",{parentName:"p"},"and(timestampBelow(), nonceEquals())")," calls.")),(0,n.kt)("br",null),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("del",{parentName:"p"},(0,n.kt)("inlineCode",{parentName:"del"},"nonceEquals"))),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"nonceEquals(\n    makerAddress: string,\n    makerNonce: number | bigint\n)\n")),(0,n.kt)("blockquote",{parentName:"li"},(0,n.kt)("p",{parentName:"blockquote"},(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"Gasless only!"))),(0,n.kt)("p",{parentName:"blockquote"},"For usual Limit Order and P2P use ",(0,n.kt)("a",{parentName:"p",href:"./series-nonce-manager"},(0,n.kt)("inlineCode",{parentName:"a"},"SeriesNonceManagerPredicateBuilder.nonceEquals(\u2026)"))," together with ",(0,n.kt)("inlineCode",{parentName:"p"},"arbitraryStaticCall(\u2026)"),". ",(0,n.kt)("br",null),"\nSee examples below.")),(0,n.kt)("p",{parentName:"li"},"  The predicate checks that the ",(0,n.kt)("inlineCode",{parentName:"p"},"makerNonce")," is equal to the nonce of ",(0,n.kt)("inlineCode",{parentName:"p"},"makerAddress"),"."))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("del",{parentName:"p"},(0,n.kt)("inlineCode",{parentName:"del"},"timestampBelow"))),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"timestampBelow(timestamp: number | bigint)\n")),(0,n.kt)("p",{parentName:"li"},"  The predicate checks that ",(0,n.kt)("inlineCode",{parentName:"p"},"timestamp")," (seconds integer) is greater than the current time."))),(0,n.kt)("br",null),(0,n.kt)("br",null),(0,n.kt)("h2",{id:"examples"},"Examples"),(0,n.kt)("p",null,"Preparation code:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"import Web3 from 'web3';\nimport {\n    limirOrderProtocolAdresses,\n    seriesNonceManagerContractAddresses,\n    Erc20Facade,\n    LimitOrderBuilder,\n    LimitOrderProtocolFacade,\n    LimitOrderPredicateBuilder,\n    NonceSeriesV2,\n    SeriesNonceManagerFacade,\n    Web3ProviderConnector\n} from '@1inch/limit-order-protocol-utils';\n\n\nconst connector = new Web3ProviderConnector(new Web3('...'));\nconst contractAddress = limirOrderProtocolAdresses[chainId];\nconst seriesContractAddress = seriesNonceManagerContractAddresses[chainId];\n\nconst limitOrderProtocolFacade = new LimitOrderProtocolFacade(contractAddress, chainId, connector);\nconst seriesNonceManagerFacade = new SeriesNonceManagerFacade(seriesContractAddress, chainId, connector);\nconst seriesNonceManagerPredicateBuilder = new SeriesNonceManagerPredicateBuilder(seriesContractAddress, chainId, connector);\nconst erc20Facade = new Erc20Facade(connector);\nconst limitOrderPredicateBuilder = new LimitOrderPredicateBuilder(limitOrderProtocolFacade);\n\nconst {\n    or,\n    and,\n    timestampBelow,\n    nonceEquals,\n    timestampBelowAndNonceEquals,\n    gt,\n    lt,\n    eq,\n    arbitraryStaticCall,\n} = limitOrderPredicateBuilder;\n\n// Example data\nconst makerAddress = '0x5fa31604fc5dcebfcac2481f9fa59d174126e5e6';\nconst makerAsset = '0xcc83bc1050244c98ac562f9faff408f069a137d7';\nconst minimumAllowedBalance = 10;\nconst expiration = 5444440000; // Some moment in future\nconst currentNonce = 4;\n")),(0,n.kt)("p",null,"Simple predicate for usual Limit-Order or P2P"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"// Because timestampBelowAndNonceEquals is method of another contract arbitraryStaticCall() is necessary\nconst simpleLimitOrderPredicate: LimitOrderPredicateCallData = arbitraryStaticCall(\n    seriesNonceManagerPredicateBuilder.facade,\n    seriesNonceManagerPredicateBuilder.timestampBelowAndNonceEquals(\n        NonceSeriesV2.LimitOrderV3,\n        expiration,\n        nonce,\n        walletAddress,\n    ),\n);\n")),(0,n.kt)("p",null,"Complex predicate for usual Limit-Order or P2P"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"const predicate = and(\n    // Because timestampBelowAndNonceEquals is method of another contract arbitraryStaticCall() is necessary\n    arbitraryStaticCall(\n        seriesNonceManagerPredicateBuilder.facade,\n        seriesNonceManagerPredicateBuilder.timestampBelowAndNonceEquals(\n            NonceSeriesV2.LimitOrderV3,\n            expiration,\n            nonce,\n            walletAddress,\n        ),\n    ),\n    gt(\n        minimumAllowedBalance,\n        arbitraryStaticCall(\n            makerAsset, // target address. Token contract in this case\n            erc20Facade.balanceOf(\n                makerAsset,\n                walletAddress,\n            )\n        )\n    ),\n);\n")),(0,n.kt)("p",null,"Simple predicate for Gasless order"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const simplePredicate: LimitOrderPredicateCallData = timestampBelowAndNonceEquals(\n    expiration,\n    currentNonce,\n    makerAddress,\n);\n")),(0,n.kt)("p",null,"Complex predicate for Gasless order"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ts"},"const balanceOfCalldata = arbitraryStaticCall(\n    makerAsset, // target address. Token contract in this case\n    erc20Facade.balanceOf(\n        makerAsset,\n        walletAddress,\n    )\n);\nconst complexPredicate: LimitOrderPredicateCallData = or(\n    and(\n        timestampBelowAndNonceEquals(\n            expiration,\n            currentNonce,\n            makerAddress,\n        ),\n        gt('10', makerAsset, balanceOfCalldata),\n    ),\n    or(\n        timestampBelow(expiration),\n        lt('20', makerAsset, balanceOfCalldata),\n    ),\n    eq('30', makerAsset, balanceOfCalldata),\n);\n")))}m.isMDXComponent=!0}}]);