"use strict";(self.webpackChunk_1_inch_docs=self.webpackChunk_1_inch_docs||[]).push([[6437],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>f});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=d(n),h=r,f=u["".concat(s,".").concat(h)]||u[h]||p[h]||o;return n?a.createElement(f,i(i({ref:t},l),{},{components:n})):a.createElement(f,i({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[u]="string"==typeof e?e:r,i[1]=c;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},37008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_label:"Reading transaction input data"},i=void 0,c={unversionedId:"educational-resources/advanced/transaction-data",id:"educational-resources/advanced/transaction-data",title:"transaction-data",description:"A guide to reading transaction input data",source:"@site/docs/educational-resources/advanced/transaction-data.mdx",sourceDirName:"educational-resources/advanced",slug:"/educational-resources/advanced/transaction-data",permalink:"/docs/educational-resources/advanced/transaction-data",draft:!1,editUrl:"https://github.com/1inch/1inch-docs/edit/master/docs/educational-resources/advanced/transaction-data.mdx",tags:[],version:"current",frontMatter:{sidebar_label:"Reading transaction input data"},sidebar:"tutorialSidebar",previous:{title:"What is MEV?",permalink:"/docs/educational-resources/advanced/finding-mev"}},s={},d=[],l={toc:d},u="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A guide to reading transaction input data"),(0,r.kt)("p",null,"In this article, we'll learn how to read and decode the raw calldata that's passed to Ethereum smart contracts. The calldata contains the function signature and arguments passed to the function."),(0,r.kt)("p",null,"We can start with something simple like\n",(0,r.kt)("inlineCode",{parentName:"p"},"0xb7760c8f000000000000000000000000000000000000000000000000000000004d866d9200000000000000000000000068b3465833fb72a70ecdf485e0e4c7bd8665fc45")),(0,r.kt)("p",null,"To start, we need to extract the function signature from the first four bytes of the calldata. These four bytes represent the function selector, which uniquely identifies each function in the contract. We can use a web3 library to extract the function selector and match it to the corresponding function in the contract. If you don't have this, you can just use a tool like ",(0,r.kt)("a",{parentName:"p",href:"https://4byte.directory/"},"https://4byte.directory/")," to look up the function selector."),(0,r.kt)("p",null,"Once we have the function selector, we can use the function signature to determine the number and type of arguments that are passed to the function. For example, the function signature for the transfer function in the ERC20 standard is 0xa9059cbb, which corresponds to the function transfer(address to, uint256 value). The first argument is an address, which is 20 bytes long, and the second argument is a uint256, which is 32 bytes long. We can use this information to extract the arguments from the calldata."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// transfer(uint256 amount, address to)\n0xb7760c8f \n// arguments\n000000000000000000000000000000000000000000000000000000004d866d9200000000000000000000000068b3465833fb72a70ecdf485e0e4c7bd8665fc45\n")),(0,r.kt)("p",null,"Now that the function selector and arguments are separated, the arguments can be decoded. In their most basic form, every argument is padded to 32 bytes. This is because the calldata is stored in 32 byte slots. We can use this information to extract the arguments from the calldata."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// uint256 amount\n000000000000000000000000000000000000000000000000000000004d866d92\n// address to\n00000000000000000000000068b3465833fb72a70ecdf485e0e4c7bd8665fc45\n")),(0,r.kt)("p",null,"This is a lot more readable now. The amount is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x4d866d92")," and the address is ",(0,r.kt)("inlineCode",{parentName:"p"},"0x68b3465833fb72a70ecdf485e0e4c7bd8665fc45")),(0,r.kt)("p",null,"##Dynamic variables"),(0,r.kt)("p",null,"Transaction data containing information that is not a fixed size is much harder to decode. These types would be something like a string or bytes. "),(0,r.kt)("p",null,'To show how complicated strings can be, consider the following example of "hello world" encoded as a parameter.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x\n0000000000000000000000000000000000000000000000000000000000000020\n000000000000000000000000000000000000000000000000000000000000000c\n48656c6c6f20576f726c64210000000000000000000000000000000000000000\n")),(0,r.kt)("p",null,"The first 32 bytes represent the offset to the string. The second 32 bytes represent the length of the string. The remaining bytes represent the string itself. The string is padded to 32 bytes, so the remaining bytes are 0s."),(0,r.kt)("p",null,"This is a basic outline of decoding transaction data by hand. There are many more edge cases and complications that can arise, but this should give you a good idea of how to decode transaction data. If you want to learn more, I recommend reading this ",(0,r.kt)("a",{parentName:"p",href:"https://degatchi.com/articles/reading-raw-evm-calldata/"},"https://degatchi.com/articles/reading-raw-evm-calldata/")," article. This was heavily referenced and has a lot more information to it."))}p.isMDXComponent=!0}}]);